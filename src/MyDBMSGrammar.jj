options
{
  static = true;
  DEBUG_PARSER = false;
  IGNORE_CASE = true;
}

PARSER_BEGIN(MyDBMSParser)

import java.util.ArrayList;
import JnDB.*;

public class MyDBMSParser
{
  public static final int PRINT_SYNTAX_ERROR = 0;
  public static final int PRINT_CREATE_TABLE = 1;
  public static final int PRINT_DROP_TABLE = 2;
  public static final int PRINT_DESC = 3;
  public static final int PRINT_SHOW_TABLES = 4;
  public static final int PRINT_SELECT = 5;
  public static final int PRINT_INSERT = 6;
  public static final int PRINT_DELETE = 7;

  public static JnDatabase jdb;
  
  public static void main(String args[]) throws ParseException
  {
    jdb = new JnDatabase();

    jdb.open("db/");
    
    MyDBMSParser parser = new MyDBMSParser(System.in);
    System.out.print("DB_2015-18380> ");
  
    while (true)
    {
      try
      {
        parser.command();
        break;
      }
      catch (Throwable e)
      {
        printMessage(PRINT_SYNTAX_ERROR);
        MyDBMSParser.ReInit(System.in);
      }
    }

	jdb.close();
  }

  public static void printMessage(int q)
  {
    switch(q)
    {
      case PRINT_SYNTAX_ERROR:
      	System.out.println("Syntax error");
      	break;
      case PRINT_CREATE_TABLE:
      	System.out.println("\'CREATE TABLE\' requested");
      	break;
      case PRINT_DROP_TABLE:
      	System.out.println("\'DROP TABLE\' requested");
      	break;
      case PRINT_DESC:
      	System.out.println("\'DESC\' requested");
      	break;
      case PRINT_SHOW_TABLES:
      	System.out.println("\'SHOW TABLES\' requested");
      	break;
      case PRINT_SELECT:
      	System.out.println("\'SELECT\' requested");
      	break;
      case PRINT_INSERT:
      	System.out.println("\'INSERT\' requested");
      	break;
      case PRINT_DELETE:
      	System.out.println("\'DELETE\' requested");
      	break;
    }
    System.out.print("DB_2015-18380> ");
  }
}

PARSER_END(MyDBMSParser)

SKIP : { " " | "\r" | "\t" | "\n" }

/* KEYWORDS token should be in front of LEGAL_IDENTIFIER.
 * Because javacc lexer generator choose token following rule
 * 1. choose the token that most characters are matched.
 * 2. if the number of characters matched is same, choose the token that defined earlier.
 */

TOKEN : /* Keywords */
{
  < EXIT : "exit" >
| < INT : "int" >
| < CHAR : "char" >
| < DATE : "date" >
| < CREATE : "create" >
| < DROP : "drop" >
| < DESC : "desc" >
| < SHOW : "show" >
| < SELECT : "select" >
| < INSERT : "insert" >
| < DELETE : "delete" >
| < TABLE : "table" >
| < TABLES : "tables" >
| < VALUES : "values" >
| < FROM : "from" >
| < WHERE : "where" >
| < INTO : "into" >
| < AS : "as" >
| < IS : "is" >
| < NOT : "not" >
| < OR : "or" >
| < AND : "and" >
| < NULL : "null" >
| < PRIMARY : "primary" >
| < FOREIGN : "foreign" >
| < KEY : "key" >
| < REFERENCES : "references" >
}

TOKEN :
{
  < CHAR_STRING : < QUOTE > (< NON_QUOTE_CHARACTER >)* < QUOTE > > 
| < INT_VALUE : (< SIGN >)? (< DIGIT >)+ >
| < DATE_VALUE : < NNNN > "-" < NN > "-" < NN > >
| < LEGAL_IDENTIFIER : < ALPHABET > (< ALPHABET > | < UNDERSCORE >)* >
| < #NNNN : < DIGIT > < DIGIT > < DIGIT > < DIGIT > >
| < #NN : < DIGIT > < DIGIT > >
| < COMP_OP : "<" | ">" | "=" | ">=" | "<=" | "!=" >
| < #SIGN : "+" | "-" >
| < SEMICOLON : ";" >
| < LEFT_PAREN : "(" >
| < RIGHT_PAREN : ")" >
| < COMMA : "," >
| < PERIOD : "." >
| < #UNDERSCORE : "_" >
| < ASTERISK : "*" >
| < #QUOTE : "'" >
| < #DIGIT : [ "0"-"9" ] >
| < #ALPHABET : [ "a"-"z", "A"-"Z" ] >
| < #NON_QUOTE_CHARACTER : ["~","`","!","@","#","$","%","^","&","*","(",")","-","_","=","+","[","]","{","}","\\","|",";",":",",",".","<",">","/","?"," "] | < ALPHABET > | < DIGIT > >
}

void command() :
{}
{
  queryList()
  (    ( < EXIT > < SEMICOLON > )
  | ( < EOF > )
  )
}

void queryList() :
{ int q; }
{
  (
    q = query()
    { printMessage(q); }
  )*
}

int query() :
{
  int q;
}
{
  (
    (
      createTableQuery()
      { q = PRINT_CREATE_TABLE; }
    )
  | (
      dropTableQuery()
      { q = PRINT_DROP_TABLE; }
    )
  | (
      descQuery()
      { q = PRINT_DESC; }
    )
  | (
      showTablesQuery()
      { q = PRINT_SHOW_TABLES; }
    )
  | (
      selectQuery()
      { q = PRINT_SELECT; }
    )
  | (
      insertQuery()
      { q = PRINT_INSERT; }
    )
  | (
      deleteQuery()
      { q = PRINT_DELETE; }
    )
  )
  (
    { return q; }
  )
}

void createTableQuery() :
{
  String tName;
  TableSchema schema;
}
{
  < CREATE > < TABLE >
  tName = tableName()
  { schema = new TableSchema(tName); }
  tableElementList(schema)
  < SEMICOLON >
  { jdb.createTable(tName, schema); }
}

void dropTableQuery() :
{ String tName; }
{
  < DROP > < TABLE >
  tName = tableName()
  < SEMICOLON >
  { jdb.dropTable(tName); }
}

void descQuery() :
{ String tName; }
{
  < DESC >
  tName = tableName()
  < SEMICOLON >
  { jdb.desc(tName); }
}

void showTablesQuery() :
{}
{
  < SHOW > < TABLES >
  < SEMICOLON >
  { jdb.showTables(); }
}

void selectQuery() :
{}
{
  < SELECT >
  selectList()
  tableExpression()
  < SEMICOLON >
}

void insertQuery() :
{}
{
  < INSERT > < INTO >
  tableName()
  insertColumnAndSource()
  < SEMICOLON >
}

void deleteQuery() :
{}
{
  < DELETE > < FROM >
  tableName()
  ( whereClause() )?
  < SEMICOLON >
}

void tableElementList(TableSchema schema) :
{}
{
  < LEFT_PAREN >
  tableElement(schema)
  (
    < COMMA >
    tableElement(schema)
  )*
  < RIGHT_PAREN >
}

void tableElement(TableSchema schema) :
{}
{
  columnDefinition(schema)
| tableConstraintDefinition(schema)
}

void columnDefinition(TableSchema schema) :
{
  String cName;
  Type type;
  boolean isNotNull = false;
}
{
  cName = columnName()
  type = dataType()
  (
    < NOT > < NULL >
    { isNotNull = true; }
  )?
  { schema.addColumn(cName, type, isNotNull); }
}

void tableConstraintDefinition(TableSchema schema) :
{}
{
  primaryKeyConstraint(schema)
| referentialConstraint(schema)
}

void primaryKeyConstraint(TableSchema schema) :
{ ArrayList<String> cnList; }
{
  < PRIMARY > < KEY >
  cnList = columnNameList()
  { schema.setPrimaryKey(cnList); }
}

void referentialConstraint(TableSchema schema) :
{
  String tName;
  ArrayList<String> cnList1,cnList2;
}
{
  < FOREIGN > < KEY >
  cnList1 = columnNameList()
  < REFERENCES >
  tName = tableName()
  cnList2 = columnNameList()
  { schema.setReferentialKey(cnList1, tName, cnList2); }
}


void selectList() :
{}
{
  < ASTERISK >
| (
    selectedColumn()
    (
      < COMMA >
      selectedColumn()
    )*
  )
}

void selectedColumn() :
{}
{
  (
    // both tableName and columnName are start with LEGAL_IDENTIFIER.
    // so we should LOOKAHEAD one more token to determine whether this part is exist.
    LOOKAHEAD(2)
    tableName()
    < PERIOD >
  )?
  columnName()
  (
    < AS >
    columnName()
  )?
}

void tableExpression() :
{}
{
  fromClause()
  ( whereClause() )?
}

void fromClause() :
{}
{
  < FROM >
  tableReferenceList()
}

void whereClause() :
{}
{
  < WHERE >
  booleanValueExpression()
}

void tableReferenceList() :
{}
{
  referedTable()
  (    < COMMA >
    referedTable()
  )*
}

void referedTable() :
{}
{
  tableName()
  (    < AS >
    tableName()
  )?
}

void booleanValueExpression() :
{}
{
  // if we choose booleanValueExpression() < OR > booleanTerm() , left recursion can occur(infinite loop).
  // so we can change it and write like below.
   booleanTerm()
  (
    < OR >
    booleanTerm()
  )*
}

void booleanTerm() :
{} 
{
  booleanFactor()
  (
    < AND >
    booleanFactor()
  )*
}

void booleanFactor() :
{}
{
  ( < NOT > )?
  booleanTest()
}

void booleanTest() :
{}
{
  predicate()
| parenthesizedBooleanExpression()
}

void parenthesizedBooleanExpression() :
{}
{
  < LEFT_PAREN >
  booleanValueExpression()
  < RIGHT_PAREN >
}

void predicate() :
{}
{
  // both comparisonPredicate and nullPredicate can start with < LEGAL_IDENTIFIER > "." < LEGAL_IDENTIFIER >.
  // so we should LOOKAHEAD 3 more token to determine choice point.
  LOOKAHEAD(4)
  comparisonPredicate()
| nullPredicate()
}

void nullPredicate() :
{}
{
  (
    LOOKAHEAD(2)
    tableName()
    < PERIOD >
  )?
  columnName()
  nullOperation()
}

void nullOperation() :
{}
{
  < IS >
  ( < NOT > )?
  < NULL >
}

void comparisonPredicate() :
{}
{
  compOperand()
  < COMP_OP >
  compOperand()
}

void compOperand() :
{}
{
  comparableValue()
| (
    (
      LOOKAHEAD(2)
      tableName()
      < PERIOD >
    )?
    columnName()
  )
}

void insertColumnAndSource() :
{}
{
  (    columnNameList()
  )?
  valueList()
}

ArrayList<String> columnNameList() :
{
  ArrayList<String> cnList = new ArrayList<String>();
  String cName;
}
{
  < LEFT_PAREN >
  cName = columnName()
  { cnList.add(cName); }
  (
    < COMMA >
    cName = columnName()
    { cnList.add(cName); }
  )*
  < RIGHT_PAREN >
  { return cnList; }
}

void valueList() :
{}
{
  < VALUES >
  < LEFT_PAREN >
  value()
  (    < COMMA >
    value()
  )*
  < RIGHT_PAREN >
}

void value() :
{}
{
  < NULL >
| comparableValue()
}

void comparableValue() :
{}
{
  < INT_VALUE >
| < CHAR_STRING >
| < DATE_VALUE >
}

Type dataType() :
{
  Token t,l;
  int len = -1;
}
{
  t = < INT >
| (
    t = < CHAR >
    < LEFT_PAREN >
    l = < INT_VALUE >
    < RIGHT_PAREN >
    { len = Integer.parseInt(l.toString()); }
  )
| t = < DATE >
{ return new Type(t.toString(), len); }
}

String tableName() :
{ Token l_id; }
{
  l_id = < LEGAL_IDENTIFIER >
  { return l_id.toString(); }
}

String columnName() :
{ Token l_id; }
{
  l_id = < LEGAL_IDENTIFIER >
  { return l_id.toString(); }
}
